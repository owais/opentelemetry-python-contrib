#!/usr/bin/env python3

# Copyright The OpenTelemetry Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import ast
import json
import logging
import os
import shutil
import subprocess
from collections import defaultdict
from configparser import ConfigParser

import astor
import pkg_resources
from jinja2 import Template

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("instrumentation_list_generator")

_auto_generation_msg = """
# DO NOT EDIT. THIS FILE WAS AUTOGENERATED FROM templates/{source}.
# RUN `python scripts/generate_setup.py` TO REGENERATE.
"""

_template = """
{header}

# DO NOT EDIT. THIS FILE WAS AUTOGENERATED FROM INSTRUMENTATION PACKAGES.
# RUN `python scripts/generate_instrumentation_bootstrap.py` TO REGENERATE.

{source}
"""

_source_tmpl = """
libraries = {}
default_instrumentations = []
"""


def main():
    pwd = os.path.dirname(os.path.abspath(__file__))
    root_path = os.path.dirname(pwd)
    gen_path = os.path.join(
        root_path,
        "opentelemetry-instrumentation/src/opentelemetry/instrumentation/bootstrap_gen.py",
    )
    base_instrumentation_path = os.path.join(root_path, "instrumentation")

    default_instrumentations = ast.List(elts=[])
    libraries = ast.Dict(keys=[], values=[])
    for pkg in os.listdir(base_instrumentation_path):
        pkg_path = os.path.join(base_instrumentation_path, pkg)
        if not os.path.isdir(pkg_path):
            continue

        out = str(
            subprocess.check_output(
                "python setup.py meta", shell=True, cwd=pkg_path
            )
        )
        meta = json.loads(out.split("\\n")[1])
        instrumentation_package = "==".join((meta["name"], meta["version"],))
        if not meta["instruments"]:
            default_instrumentations.elts.append(
                ast.Str(instrumentation_package)
            )
        for target_pkg in meta["instruments"]:
            parsed = pkg_resources.Requirement.parse(target_pkg)
            libraries.keys.append(ast.Str(parsed.name))
            libraries.values.append(
                ast.Dict(
                    keys=[ast.Str("library"), ast.Str("instrumentation")],
                    values=[
                        # ast.Str(parsed.name + "".join(parsed.specs[0]) if parsed.specs else ""),
                        ast.Str(target_pkg),
                        ast.Str(instrumentation_package),
                    ],
                )
            )

    tree = ast.parse(_source_tmpl)
    tree.body[0].value = libraries
    tree.body[1].value = default_instrumentations
    source = astor.to_source(tree)

    with open(os.path.join(pwd, "license_header.txt"), "r") as f:
        header = f.read()
        source = _template.format(header=header, source=source)

    with open(gen_path, "w") as f:
        f.write(source)

    subprocess.run(["black", "-q", gen_path], check=True)


if __name__ == "__main__":
    main()
